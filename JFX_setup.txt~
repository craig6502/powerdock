Java Stage objects:

https://www.ntu.edu.sg/home/ehchua/programming/java/Javafx1_intro.html
https://docs.oracle.com/javafx/2/get_started/jfxpub-get_started.htm

General introductory text (Java 8 we are now at 9)
Beginning Java 8 Games Development
By Wallace Jackson
https://books.google.com.au/books?id=xFwnCgAAQBAJ&pg=PA89
Chp4
Event handling p95-

===========
THREADS
===========
Most people are assumed to work with 1 thread and stage initially.

But if you want to start a new thread to launch a new application see here:
https://stackoverflow.com/questions/36742940/how-to-launch-the-javafx-app-from-java-code

FXApplication application = new FXApplication();
        application.handleArgs(args);
        new Thread(application ).start();


==============
LAUNCHER IN MAIN METHOD

=============

If you setup an object that creates a primary stage, you can create additional stages in the same thread that runs that instance (i.e. that you called from the command line)

However, in every other situation, when you create an application that creates a stage from an external reference,
it looks like you should create one stage per object, and then this is run from the main thread.

You won't have any this.Stagename references in your methods, because you won't be create a new object inside the second app:
the Stage will be created as part of the 'application' (which is the extended interface for the object).

In other words, these are special kinds of objects, designed to be linked to the main calling app.

If you start to develop your code and split off the calling object so that it  no longer creates the 'application' with the Stage, you need to ensure that the object with the Stage is designed for picking up the thread and using the primary Stage created...


This requires knowledge of Java processor threading to check.  See for example here:
https://gist.github.com/andytill/3835914

There is a discussion here (https://bugs.openjdk.java.net/browse/JDK-8102211) of how the FX app is on a background thread by default, but this can be changed

"In normal FX application, the launcher looks for the FX application class, start() and/or main() and ensures that the toolkit is initialized properly before application code can run. Here is a Java example that has the same problem as JS/Nashorn:"


(1) Make your default application class the extension class.
I've tried ensuring that the new application imports the relevant javafx....Application and has this:
public class AppStart extends Application {

(even though previously it was MainStage extends application, but AppStart now calls the stage object)
(2) The second thing you do when creating this is :
"override abstract method start(Stage)"


To retrieve parameters for this Application, including any arguments, we can call getParameters() method of javafx.application.Application class. getParameters() return a Application.Parameters. We can retrieve the parameters and arguments with its getNamed(), getRaw() or getUnnamed(): 
http://java-buddy.blogspot.com.au/2014/02/get-parametersarguments-in-javafx.html
https://docs.oracle.com/javafx/2/api/javafx/application/Application.html#getParameters()

=============
MULTIPLE STAGES AS SUBCLASSES
=============


https://stackoverflow.com/questions/21073941/creating-multiple-stages-in-javafx

nb: designers have choices to switch the scene in a stage, or create a new stage with new scene, or mix both.

Qt:
In general, for most common UI use cases, rather than creating a Popup control like this sample, I find it preferable to just creating a new Stage or use newer JavaFX facilities such as Alerts and Dialogs. Popups are generally of more use to library developers rather than application developers.
https://gist.github.com/jewelsea/1926196

===========
TO DO:
Examine pros/cons of FXML for control boxes

Seems to be the "View" part of the MVC (a bit like .erb files in Ruby)
Attach controllers to the FXML files.

https://stackoverflow.com/questions/11994366/how-to-reference-primarystage
https://docs.oracle.com/javafx/2/fxml_get_started/custom_control.htm

=========
It seems the starting process has to be the driver, although you can pass of control of I/O to a controller e.g.
MyController cont=load.getController();
    /*
      This depends on your controller and you have to decide 
      How your controller need the arguments
    */
    cont.setParameter(getParameters()); 

    primaryStage.setTitle("Hive-viewer");
    primaryStage.setScene(new Scene(root, 1600, 900));
    primaryStage.show();
    